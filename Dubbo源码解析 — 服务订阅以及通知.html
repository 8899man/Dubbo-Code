<!DOCTYPE html><html><head><title>Dubbo源码解析 — 服务订阅以及通知</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        
                    

<h2 id="dubbo源码解析-服务订阅以及通知">Dubbo源码解析 — 服务订阅以及通知</h2>

<hr>

<h5 id="前言">前言<br></h5>

<p>由于服务的注册内容比较多，所以把上一部分单独做一篇，订阅和通知合在一起。<br></p>



<h5 id="subscribe">subscribe<br></h5>

<p>承接上一篇，我们说完了服务的发布，现在看看服务的订阅。考虑了一下，我还是决定在这里贴一下Protocol接口的相关注释，方便大家理解：<br></p>

<pre class="prettyprint hljs-dark"><code class="hljs gherkin">/<span class="hljs-keyword">*</span><span class="hljs-keyword">*</span><br>     <span class="hljs-keyword">*</span> 暴露远程服务：<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> 3. export()传入的Invoker由框架实现并传入，协议不需要关心。<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> <br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@param &lt;T&gt; 服务的类型</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@param invoker 服务的执行体</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@return exporter 暴露服务的引用，用于取消暴露</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@throws RpcException 当暴露服务出错时抛出，比如端口已占用</span><br>     <span class="hljs-keyword">*</span>/<br>    <span class="hljs-comment">@Adaptive</span><br>    <span class="hljs-variable">&lt;T&gt;</span> Exporter<span class="hljs-variable">&lt;T&gt;</span> export(Invoker<span class="hljs-variable">&lt;T&gt;</span> invoker) throws RpcException;<br><br>    /<span class="hljs-keyword">*</span><span class="hljs-keyword">*</span><br>     <span class="hljs-keyword">*</span> 引用远程服务：<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。<span class="hljs-variable">&lt;br&gt;</span><br>     <span class="hljs-keyword">*</span> <br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@param &lt;T&gt; 服务的类型</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@param type 服务的类型</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@param url 远程服务的URL地址</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@return invoker 服务的本地代理</span><br>     <span class="hljs-keyword">*</span> <span class="hljs-comment">@throws RpcException 当连接服务提供方失败时抛出</span><br>     <span class="hljs-keyword">*</span>/<br>    <span class="hljs-comment">@Adaptive</span><br>    <span class="hljs-variable">&lt;T&gt;</span> Invoker<span class="hljs-variable">&lt;T&gt;</span> refer(Class<span class="hljs-variable">&lt;T&gt;</span> type, URL url) throws RpcException;<br></code></pre>

<p>这里很容易就可以明白，export发布，refer引用，然后获取invoker，然后执行invoker的方法即可。<br></p>

<p>继续看一下RegistryProtocol的refer方法：<br></p>

<pre class="prettyprint hljs-dark"><code class="hljs lasso"><span class="hljs-keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; <span class="hljs-keyword">type</span>, URL url) throws RpcException {<br><br>    <span class="hljs-comment">//处理注册中心的协议，用url中registry参数的值作为真实的注册中心协议</span><br>    url = url<span class="hljs-built_in">.</span>setProtocol(url<span class="hljs-built_in">.</span>getParameter(Constants<span class="hljs-built_in">.</span>REGISTRY_KEY, Constants<span class="hljs-built_in">.</span>DEFAULT_REGISTRY))<span class="hljs-built_in">.</span>removeParameter(Constants<span class="hljs-built_in">.</span>REGISTRY_KEY);<br><br>    <span class="hljs-comment">//拿到真正的注册中心实例，我们的例子中就是zookeeperRegistry</span><br>    Registry registry = registryFactory<span class="hljs-built_in">.</span>getRegistry(url);<br><br>    <span class="hljs-keyword">if</span> (RegistryService<span class="hljs-built_in">.</span>class<span class="hljs-built_in">.</span><span class="hljs-keyword">equals</span>(<span class="hljs-keyword">type</span>)) <br>        <span class="hljs-comment">//todo 不太理解，貌似是注册中心服务本身的暴露</span><br>        <span class="hljs-keyword">return</span> proxyFactory<span class="hljs-built_in">.</span>getInvoker((T) registry, <span class="hljs-keyword">type</span>, url);<br>    }<br><br>    <span class="hljs-comment">//分组聚合处理，http://alibaba.github.io/dubbo-doc-static/Merge+By+Group-zh.htm</span><br>    <span class="hljs-comment">// group="a,b" or group="*"</span><br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; qs = StringUtils<span class="hljs-built_in">.</span>parseQueryString(url<span class="hljs-built_in">.</span>getParameterAndDecoded(Constants<span class="hljs-built_in">.</span>REFER_KEY));<br><br>    <span class="hljs-built_in">String</span> <span class="hljs-keyword">group</span> = qs<span class="hljs-built_in">.</span>get(Constants<span class="hljs-built_in">.</span>GROUP_KEY);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">group</span> != <span class="hljs-built_in">null</span> <span class="hljs-subst">&amp;&amp;</span> <span class="hljs-keyword">group</span><span class="hljs-built_in">.</span>length() &gt; <span class="hljs-number">0</span> ) {<br>        <span class="hljs-keyword">if</span> ( ( Constants<span class="hljs-built_in">.</span>COMMA_SPLIT_PATTERN<span class="hljs-built_in">.</span>split( <span class="hljs-keyword">group</span> ) )<span class="hljs-built_in">.</span>length &gt; <span class="hljs-number">1</span><br>                <span class="hljs-subst">||</span> <span class="hljs-string">"*"</span><span class="hljs-built_in">.</span><span class="hljs-keyword">equals</span>( <span class="hljs-keyword">group</span> ) ) {<br>            <span class="hljs-keyword">return</span> doRefer( getMergeableCluster(), registry, <span class="hljs-keyword">type</span>, url );<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> doRefer(cluster, registry, <span class="hljs-keyword">type</span>, url);<br>}<br></code></pre>

<p>继续看一下doRefer方法：<br></p>

<pre class="prettyprint hljs-dark"><code class="hljs elm"><span class="hljs-title">private</span> &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Invoker</span>&lt;<span class="hljs-type">T</span>&gt; doRefer(<span class="hljs-type">Cluster</span> cluster, <span class="hljs-type">Registry</span> registry, <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-typedef"><span class="hljs-keyword">type</span>, <span class="hljs-type">URL</span> url) <span class="hljs-container">{<br><br>    //这个directory把同一个serviceInterface对应的多个invoker管理起来提供概念上的化多为单一，供路由、均衡算法等使用<br>    <span class="hljs-type">RegistryDirectory</span>&lt;<span class="hljs-type">T</span>&gt; directory = new <span class="hljs-type">RegistryDirectory</span>&lt;<span class="hljs-type">T</span>&gt;(type, url);<br>    directory.setRegistry(registry);<br>    directory.setProtocol(protocol);<br>    <span class="hljs-type">URL</span> subscribeUrl = new <span class="hljs-type">URL</span>(<span class="hljs-type">Constants</span>.<span class="hljs-type">CONSUMER_PROTOCOL</span>, <span class="hljs-type">NetUtils</span>.getLocalHost(), 0, type.getName(), directory.getUrl().getParameters());<br><br>    //注册自己<br>    if (! <span class="hljs-type">Constants</span>.<span class="hljs-type">ANY_VALUE</span>.equals(url.getServiceInterface())<br>            &amp;&amp; url.getParameter(<span class="hljs-type">Constants</span>.<span class="hljs-type">REGISTER_KEY</span>, true)) {<br>        registry.register(subscribeUrl.addParameters(<span class="hljs-type">Constants</span>.<span class="hljs-type">CATEGORY_KEY</span>, <span class="hljs-type">Constants</span>.<span class="hljs-type">CONSUMERS_CATEGORY</span>,<br>                <span class="hljs-type">Constants</span>.<span class="hljs-type">CHECK_KEY</span>, <span class="hljs-type">String</span>.valueOf(false)));<br>    }</span></span><br><br>    //订阅目标服务提供方<br>    directory.subscribe(subscribeUrl.addParameter(<span class="hljs-type">Constants</span>.<span class="hljs-type">CATEGORY_KEY</span>, <span class="hljs-type">Constants</span>.<span class="hljs-type">PROVIDERS_CATEGORY</span> <br>    + <span class="hljs-string">","</span> + <span class="hljs-type">Constants</span>.<span class="hljs-type">CONFIGURATORS_CATEGORY</span> <br>    + <span class="hljs-string">","</span> + <span class="hljs-type">Constants</span>.<span class="hljs-type">ROUTERS_CATEGORY</span>));<br><br>    //合并所有相同invoker<br>    return cluster.join(directory);<br>}<br></code></pre>

<p><em>服务消费方不仅会订阅相关的服务，也会注册自身供其他层使用（服务治理）</em>。特别要注意的是订阅时，同时订阅了三个分类类型：<strong><em>providers，routers，configurators</em></strong>。<br></p>

<p>继续深挖dubbo中服务消费方订阅服务的细节，上面方法中最终把订阅细节委托给RegistryDirectory.subscribe方法，注意，这个方法接受的参数，此时的url已经把category设置为providers，routers，configurators：<br></p>



<pre class="prettyprint hljs-dark"><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(URL url)</span> </span>{<br>    setConsumerUrl(url);<br>    registry.subscribe(url, <span class="hljs-keyword">this</span>);<br>}<br></code></pre>

<p>这里registry就是zookeeperRegistry，这在doRefer方法可以看到明确的注入。然后和注册服务时一样，订阅会先由FailbackRegistry完成失效重试的处理，最终会交给zookeeperRegistry.doSubscribe方法。zookeeperRegistry实例拥有ZookeeperClient类型引用，该类型对象封装了和zookeeper通信的逻辑（默认是使用zkclient客户端）。我们在doSubscribe中能看到对zkClient的使用，而在ZK中的路径模式，统一看上一篇关于服务注册的最后一张图。<br></p>

<p>订阅之后，下面我们讲解notify，我们在doSubscribe中可以看到NotifyListener的调用。<br></p>



<h5 id="notify">Notify<br></h5>

<p>这里先解决一个小问题，之前在其他博客上也看到过，dubbo中有一个ChildListener接口，并且我们在ZookeeperRegistry中会看到如下：<br></p>

<pre class="prettyprint hljs-dark"><code class="hljs actionscript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt;();<br></code></pre>

<p>这里我还没用细究这个ChildListener的作用，借鉴了一篇博客里的讲解：<br></p>

<blockquote>
  <p>这个ChildListener接口用于<strong>把zkclient的事件（IZkChildListener）转换到registry事件（NotifyListener）</strong>。这么做的深意不是特别的理解，可能是因为我并没有太多zookeeper的使用经验导致的，这里的做法可以<em>更好的把zkclient的api和dubbo真身的注册中心逻辑分离开</em>，毕竟dubbo除了zkclient以外还可以选择curator。<br></p>
</blockquote>

<p>我们主要看一下RegistryDirectory的notify方法：<br></p>

<pre class="prettyprint hljs-dark"><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> notify(List&lt;URL&gt; urls) {<br><br>    ...<br><br>    <span class="hljs-comment">// configurators 更新缓存的服务提供方配置规则</span><br>    <span class="hljs-keyword">if</span> (configuratorUrls != <span class="hljs-keyword">null</span> &amp;&amp; configuratorUrls.<span class="hljs-keyword">size</span>() &gt;<span class="hljs-number">0</span> ) {<br>        <span class="hljs-keyword">this</span>.configurators = toConfigurators(configuratorUrls);<br>    }<br><br>    <span class="hljs-comment">// routers  更新缓存的路由配置规则</span><br>    <span class="hljs-keyword">if</span> (routerUrls != <span class="hljs-keyword">null</span> &amp;&amp; routerUrls.<span class="hljs-keyword">size</span>() &gt;<span class="hljs-number">0</span> ){<br>        List&lt;Router&gt; routers = toRouters(routerUrls);<br>        <span class="hljs-keyword">if</span>(routers != <span class="hljs-keyword">null</span>){ <span class="hljs-comment">// null - do nothing</span><br>            setRouters(routers);<br>        }<br>    }<br><br>    <span class="hljs-comment">// 合并override参数</span><br>    List&lt;Configurator&gt; localConfigurators = <span class="hljs-keyword">this</span>.configurators;<br><br>    <span class="hljs-keyword">this</span>.overrideDirectoryUrl = directoryUrl;<br>    <span class="hljs-keyword">if</span> (localConfigurators != <span class="hljs-keyword">null</span> &amp;&amp; localConfigurators.<span class="hljs-keyword">size</span>() &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">for</span> (Configurator configurator : localConfigurators) {<br>            <span class="hljs-keyword">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);<br>        }<br>    }<br><br>    <span class="hljs-comment">// providers</span><br>    refreshInvoker(invokerUrls);<br>}<br></code></pre>

<p>这里在每次消费方接受到注册中心的通知后，大概会做下面这些事儿：<br></p>

<ul><li>更新服务提供方的配置规则<br></li>
<li>更新路由规则<br></li>
<li>重建invoker实例<br></li>
</ul>

<p>我们这里主要看dubbo如何“重建invoker实例”，也就是最后一行代码调用的方法refreshInvoker：<br></p>

<pre class="prettyprint hljs-dark"><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> refreshInvoker(List&lt;URL&gt; invokerUrls){<br>    <span class="hljs-keyword">if</span> (invokerUrls != <span class="hljs-keyword">null</span> &amp;&amp; invokerUrls.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; invokerUrls.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span> &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>).getProtocol())) { <br><br>        <span class="hljs-comment">//如果传入的参数只包含一个empty://协议的url，表明禁用当前服务</span><br>        <span class="hljs-keyword">this</span>.forbidden = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 禁止访问</span><br>        <span class="hljs-keyword">this</span>.methodInvokerMap = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 置空列表</span><br>        destroyAllInvokers(); <span class="hljs-comment">// 关闭所有Invoker</span><br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">this</span>.forbidden = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 允许访问</span><br>        Map&lt;<span class="hljs-keyword">String</span>, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="hljs-keyword">this</span>.urlInvokerMap;<br><br>        <span class="hljs-keyword">if</span> (invokerUrls.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.cachedInvokerUrls != <span class="hljs-keyword">null</span>) {<br>             <span class="hljs-comment">//如果传入的invokerUrl列表是空，则表示只是下发的override规则或route规则，需要重新交叉对比，决定是否需要重新引用</span><br>            invokerUrls.addAll(<span class="hljs-keyword">this</span>.cachedInvokerUrls);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">this</span>.cachedInvokerUrls = <span class="hljs-keyword">new</span> HashSet&lt;URL&gt;();<br>            <span class="hljs-comment">//缓存invokerUrls列表，便于交叉对比</span><br>            <span class="hljs-keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);<br>        }<br><br>        <span class="hljs-keyword">if</span> (invokerUrls.<span class="hljs-built_in">size</span>() ==<span class="hljs-number">0</span> ){<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        Map&lt;<span class="hljs-keyword">String</span>, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls) ;<span class="hljs-comment">// 将URL列表转成Invoker列表</span><br>        Map&lt;<span class="hljs-keyword">String</span>, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); <span class="hljs-comment">// 换方法名映射Invoker列表</span><br><br>        <span class="hljs-comment">// state change</span><br>        <span class="hljs-comment">//如果计算错误，则不进行处理.</span><br>        <span class="hljs-keyword">if</span> (newUrlInvokerMap == <span class="hljs-keyword">null</span> || newUrlInvokerMap.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> ) {<br><br>            logger.error(<span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"urls to invokers error .invokerUrls.size :"</span>+invokerUrls.<span class="hljs-built_in">size</span>() + <span class="hljs-string">", invoker.size :0. urls :"</span>+invokerUrls.toString()));<br>            <span class="hljs-keyword">return</span> ;<br>        }<br><br>        <span class="hljs-keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;<br>        <span class="hljs-keyword">this</span>.urlInvokerMap = newUrlInvokerMap;<br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 关闭未使用的Invoker</span><br>            destroyUnusedInvokers(oldUrlInvokerMap,newUrlInvokerMap);<br>        }<span class="hljs-keyword">catch</span> (Exception e) {<br>            logger.warn(<span class="hljs-string">"destroyUnusedInvokers error. "</span>, e);<br>        }<br>    }<br>}<br></code></pre>

<p>到这里我们已经完成了服务通知的业务逻辑，有兴趣的童鞋可以深究一下toInvokers方法，它又会走一遍url -&gt; invoker的逻辑（服务引用）。</p></div></body></html>